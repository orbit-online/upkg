#!/usr/bin/env bash
# shellcheck source-path=.. disable=2059,2064
set -Eeo pipefail; shopt -s inherit_errexit

upkg() {
  local pkgroot; pkgroot=$(realpath "$(dirname "$(realpath "${BASH_SOURCE[0]}")")/..")
  # shellcheck disable=SC1091
  source "$pkgroot/.upkg/records.sh/records.sh"
  type "jq" >/dev/null 2>&1 || fatal "command not found: 'jq'"
  local upkg_new=$pkgroot/.upkg/upkg-new/bin/upkg
  local upkg_old=$pkgroot/.upkg/upkg-old
  case "$1" in
    add|remove)
      ! is_legacy_pkgroot || fatal ".upkg looks to be managed by v0.13.0 still, please remove it before running μpkg v0.20.0+"
      exec "$upkg_new" "$@"
      ;;
    bundle) exec "$upkg_new" "$@" ;;
    uninstall|root) exec "$upkg_old" "$@" ;;
    list)
      if [[ $# -gt 2 ]]; then
        exec "$upkg_new" "$@"
      elif [[ $# -eq 2 && $2 = -g ]]; then
        printf "μpkg legacy packages:\n"
        "$upkg_old" "$@"
        printf "μpkg packages:\n"
        exec "$upkg_new" "$@"
      elif is_legacy_pkgroot; then
        exec "$upkg_old" "$@"
      else
        exec "$upkg_new" "$@"
      fi
      ;;
    install)
      local arg
      for arg in "$@"; do
        [[ $arg != */* ]] || exec "$upkg_old" "$@"
      done
      if is_legacy_pkgroot; then
        exec "$upkg_old" "$@"
      else
        exec "$upkg_new" "$@"
      fi
      ;;
    *) exec "$upkg_new" "$@" ;;
  esac
}

is_legacy_pkgroot() {
  if [[ -e .upkg/.packages ]]; then
    return 1
  elif [[ -e upkg.json ]]; then
    ! jq -re '.commands // .assets // (.dependencies | type!="array") // false' upkg.json >/dev/null || return 0
  fi
  # Assume new
  return 1
}

upkg "$@"
